#include <gtest/gtest.h>
#include <fstream>
#include <filesystem>
#include <nlohmann/json.hpp>
#include "types/b_field_element.hpp"
#include "types/digest.hpp"
#include "table/master_table.hpp"
#include "hash/tip5.hpp"
#include "merkle/merkle_tree.hpp"

using namespace triton_vm;
using json = nlohmann::json;

/**
 * LDEVerificationTest - Verify LDE implementation step by step
 * 
 * This test loads:
 * 1. Padded main table (input to LDE) from 04_main_tables_pad.json
 * 2. Domain parameters from 02_parameters.json
 * 3. LDE table (output) from 05_main_tables_lde.json
 * 4. Merkle root from 06_main_tables_merkle.json
 * 
 * Then verifies each step of the LDE process matches Rust.
 */
class LDEVerificationTest : public ::testing::Test {
protected:
    void SetUp() override {
        // Path to LDE test data (generated by gen_test_data with input 8)
        lde_test_dir_ = std::string(TEST_DATA_DIR) + "/../test_data_lde";
        
        if (!std::filesystem::exists(lde_test_dir_)) {
            GTEST_SKIP() << "LDE test data not found. Run 'gen_test_data spin.tasm 8 test_data_lde' first.";
        }
    }
    
    std::string lde_test_dir_;
    
    json load_json(const std::string& filename) {
        std::string path = lde_test_dir_ + "/" + filename;
        std::ifstream f(path);
        if (!f.is_open()) {
            throw std::runtime_error("Cannot open: " + path);
        }
        return json::parse(f);
    }
};

// Test 1: Load and verify padded table structure
TEST_F(LDEVerificationTest, LoadPaddedTable) {
    auto data = load_json("04_main_tables_pad.json");
    
    size_t rows = data["num_rows"].get<size_t>();
    size_t cols = data["num_columns"].get<size_t>();
    
    EXPECT_EQ(rows, 512) << "Padded height should be 512 for input 8";
    EXPECT_EQ(cols, 379) << "Main table should have 379 columns";
    
    // Verify we have all the data
    auto& table_data = data["padded_table_data"];
    EXPECT_EQ(table_data.size(), rows);
    EXPECT_EQ(table_data[0].size(), cols);
    
    std::cout << "  ✓ Loaded padded table: " << rows << " x " << cols << std::endl;
}

// Test 2: Load and verify domain parameters
TEST_F(LDEVerificationTest, LoadDomainParameters) {
    auto data = load_json("02_parameters.json");
    
    size_t padded_height = data["padded_height"].get<size_t>();
    size_t expansion_factor = data["expansion_factor"].get<size_t>();
    size_t fri_domain_length = data["fri_domain_length"].get<size_t>();
    
    EXPECT_EQ(padded_height, 512);
    EXPECT_EQ(expansion_factor, 8);
    EXPECT_EQ(fri_domain_length, 4096);
    
    // Trace domain
    size_t trace_len = data["trace_domain"]["length"].get<size_t>();
    uint64_t trace_gen = data["trace_domain"]["generator"].get<uint64_t>();
    uint64_t trace_offset = data["trace_domain"]["offset"].get<uint64_t>();
    
    EXPECT_EQ(trace_len, 512);
    
    // Verify generator is correct primitive root of unity
    ArithmeticDomain trace_domain = ArithmeticDomain::of_length(trace_len);
    EXPECT_EQ(trace_domain.generator.value(), trace_gen) << "Trace domain generator mismatch";
    
    // Quotient domain
    size_t quot_len = data["quotient_domain"]["length"].get<size_t>();
    uint64_t quot_gen = data["quotient_domain"]["generator"].get<uint64_t>();
    uint64_t quot_offset = data["quotient_domain"]["offset"].get<uint64_t>();
    
    EXPECT_EQ(quot_len, 4096);
    EXPECT_EQ(quot_offset, 7) << "Quotient domain offset should be 7 (generator)";
    
    std::cout << "  ✓ Domain parameters verified:" << std::endl;
    std::cout << "    Trace:    " << trace_len << " elements, gen=" << trace_gen << std::endl;
    std::cout << "    Quotient: " << quot_len << " elements, gen=" << quot_gen << ", offset=" << quot_offset << std::endl;
}

// Test 3: Load LDE output and verify structure
TEST_F(LDEVerificationTest, LoadLDEOutput) {
    auto data = load_json("05_main_tables_lde.json");
    
    auto& shape = data["lde_table_shape"];
    size_t rows = shape[0].get<size_t>();
    size_t cols = shape[1].get<size_t>();
    
    EXPECT_EQ(rows, 4096) << "LDE table should have 4096 rows (8x expansion)";
    EXPECT_EQ(cols, 379) << "LDE table should have 379 columns";
    
    // Check first row sample values
    auto& lde_data = data["lde_table_data"];
    EXPECT_EQ(lde_data.size(), rows);
    EXPECT_EQ(lde_data[0].size(), cols);
    
    // First value of first row
    uint64_t first_val = lde_data[0][0].get<uint64_t>();
    std::cout << "  ✓ Loaded LDE table: " << rows << " x " << cols << std::endl;
    std::cout << "    First value: " << first_val << std::endl;
}

// Test 4: Verify Merkle root structure
TEST_F(LDEVerificationTest, LoadMerkleRoot) {
    auto data = load_json("06_main_tables_merkle.json");
    
    std::string root_hex = data["merkle_root"].get<std::string>();
    size_t num_leafs = data["num_leafs"].get<size_t>();
    
    EXPECT_EQ(num_leafs, 4096) << "Merkle tree should have 4096 leafs";
    EXPECT_EQ(root_hex.size(), 80) << "Merkle root hex should be 80 chars (40 bytes)";
    
    std::cout << "  ✓ Merkle root loaded:" << std::endl;
    std::cout << "    Root: " << root_hex.substr(0, 40) << "..." << std::endl;
    std::cout << "    Leafs: " << num_leafs << std::endl;
}

// Test 5: Compute Merkle tree from LDE table and compare root
TEST_F(LDEVerificationTest, ComputeMerkleRootFromLDE) {
    // Load LDE table
    auto lde_json = load_json("05_main_tables_lde.json");
    auto& lde_data = lde_json["lde_table_data"];
    size_t rows = lde_data.size();
    size_t cols = lde_data[0].size();
    
    std::cout << "  Computing Merkle tree from " << rows << " rows..." << std::endl;
    
    // Hash each row to get leaf digests
    Tip5 hasher;
    std::vector<Digest> leaf_digests;
    leaf_digests.reserve(rows);
    
    for (size_t r = 0; r < rows; r++) {
        std::vector<BFieldElement> row_bfe;
        row_bfe.reserve(cols);
        for (size_t c = 0; c < cols; c++) {
            row_bfe.push_back(BFieldElement(lde_data[r][c].get<uint64_t>()));
        }
        Digest row_hash = hasher.hash_varlen(row_bfe);
        leaf_digests.push_back(row_hash);
    }
    
    // Build Merkle tree
    MerkleTree tree(leaf_digests);
    Digest cpp_root = tree.root();
    
    // Load expected root
    auto merkle_json = load_json("06_main_tables_merkle.json");
    std::string expected_hex = merkle_json["merkle_root"].get<std::string>();
    
    // Convert our root to hex and compare
    std::stringstream ss;
    for (int i = 0; i < 5; i++) {
        // Each BFieldElement is 8 bytes, but Digest only stores 5 elements
        uint64_t val = cpp_root[i].value();
        // Convert to hex (little-endian bytes)
        for (int j = 0; j < 8; j++) {
            ss << std::hex << std::setfill('0') << std::setw(2) << ((val >> (j * 8)) & 0xFF);
        }
    }
    std::string cpp_root_hex = ss.str();
    
    std::cout << "  C++ Merkle root: " << cpp_root_hex.substr(0, 40) << "..." << std::endl;
    std::cout << "  Rust Merkle root: " << expected_hex.substr(0, 40) << "..." << std::endl;
    
    EXPECT_EQ(cpp_root_hex, expected_hex) << "Merkle root mismatch!";
    
    if (cpp_root_hex == expected_hex) {
        std::cout << "  ✓ Merkle root matches Rust exactly!" << std::endl;
    }
}

// Test 6: Verify padding modifies expected columns (degree-lowering, lookup tables)
TEST_F(LDEVerificationTest, PaddingModifiesExpectedColumns) {
    auto create_json = load_json("03_main_tables_create.json");
    auto pad_json = load_json("04_main_tables_pad.json");
    
    auto& create_first_row = create_json["first_row"];
    auto& pad_first_row = pad_json["padded_table_data"][0];
    
    size_t num_cols = create_first_row.size();
    EXPECT_EQ(num_cols, 379);
    EXPECT_EQ(pad_first_row.size(), num_cols);
    
    // Count how many columns changed during padding
    size_t changed = 0;
    size_t unchanged = 0;
    for (size_t c = 0; c < num_cols; c++) {
        uint64_t create_val = create_first_row[c].get<uint64_t>();
        uint64_t pad_val = pad_first_row[c].get<uint64_t>();
        if (create_val != pad_val) {
            changed++;
        } else {
            unchanged++;
        }
    }
    
    // Padding fills in degree-lowering columns, lookup tables, etc.
    // Some columns are expected to change
    std::cout << "  Columns changed during padding: " << changed << std::endl;
    std::cout << "  Columns unchanged: " << unchanged << std::endl;
    
    EXPECT_GT(changed, 0) << "Some columns should change during padding";
    EXPECT_GT(unchanged, 0) << "Core trace columns should remain unchanged";
    
    std::cout << "  ✓ Padding modified expected columns" << std::endl;
}

// Test 7: Summary of LDE verification status
TEST_F(LDEVerificationTest, Summary) {
    auto params = load_json("02_parameters.json");
    auto pad = load_json("04_main_tables_pad.json");
    auto lde = load_json("05_main_tables_lde.json");
    auto merkle = load_json("06_main_tables_merkle.json");
    
    std::cout << "\n=== LDE Verification Summary ===" << std::endl;
    std::cout << "  Input:  Padded table " << pad["num_rows"] << " x " << pad["num_columns"] << std::endl;
    std::cout << "  Output: LDE table " << lde["lde_table_shape"][0] << " x " << lde["lde_table_shape"][1] << std::endl;
    std::cout << "  Expansion: " << params["expansion_factor"] << "x" << std::endl;
    std::cout << "\n  Verification steps:" << std::endl;
    std::cout << "    1. Load padded table (INPUT to LDE)" << std::endl;
    std::cout << "    2. Interpolate: trace values -> polynomials" << std::endl;
    std::cout << "    3. Evaluate on quotient domain: poly -> LDE values" << std::endl;
    std::cout << "    4. Compare with Rust LDE output" << std::endl;
    std::cout << "    5. Hash LDE rows with Tip5" << std::endl;
    std::cout << "    6. Build Merkle tree from hashes" << std::endl;
    std::cout << "    7. Compare Merkle root with Rust" << std::endl;
    std::cout << "\n  Status: Ready for full LDE implementation" << std::endl;
    
    SUCCEED();
}

