#pragma once

#include <string>
#include <vector>
#include <nlohmann/json.hpp>
#include "types/b_field_element.hpp"
#include "types/x_field_element.hpp"
#include "types/digest.hpp"

namespace triton_vm {

/**
 * TestDataLoader - Load test data from JSON files for functional verification
 * 
 * This class loads the test data generated by the Rust implementation
 * and provides methods to access it for verification in unit tests.
 */
class TestDataLoader {
public:
    explicit TestDataLoader(const std::string& test_data_dir);
    
    // Load specific step data
    nlohmann::json load_step(int step_num, const std::string& name) const;
    
    // Step 1: Trace execution
    struct TraceExecutionData {
        size_t processor_trace_height;
        size_t processor_trace_width;
        size_t padded_height;
        std::vector<uint64_t> public_output;
    };
    TraceExecutionData load_trace_execution() const;
    
    // Step 2: Parameters
    struct ParametersData {
        size_t padded_height;
        uint32_t log2_padded_height;
        size_t fri_domain_length;
        size_t trace_domain_length;
        size_t randomized_trace_domain_length;
        size_t quotient_domain_length;
    };
    ParametersData load_parameters() const;
    
    // Step 3: Main tables create
    struct MainTableCreateData {
        std::array<size_t, 2> trace_table_shape;
        size_t num_columns;
        std::vector<uint64_t> first_row;
    };
    MainTableCreateData load_main_table_create() const;
    
    // Step 6: Merkle tree root (legacy - use load_main_tables_merkle_full)
    struct MerkleRootData {
        std::string merkle_root_hex;
    };
    MerkleRootData load_main_tables_merkle() const;
    MerkleRootData load_aux_tables_merkle() const;
    MerkleRootData load_quotient_merkle() const;
    
    // Step 7: Fiat-Shamir challenges
    struct ChallengesData {
        size_t num_challenges;
        std::vector<std::array<std::string, 3>> challenges; // XFieldElement as 3 strings
    };
    ChallengesData load_fiat_shamir_challenges() const;
    
    // Step 7: Aux tables create
    struct AuxTableCreateData {
        std::array<size_t, 2> aux_table_shape;
        size_t num_columns;
    };
    AuxTableCreateData load_aux_table_create() const;
    
    // Step 10: Quotient calculation
    struct QuotientCalculationData {
        bool cached;
        std::string note;
    };
    QuotientCalculationData load_quotient_calculation() const;
    
    // Step 12: Quotient hash rows
    struct QuotientHashRowsData {
        size_t num_quotient_segment_digests;
    };
    QuotientHashRowsData load_quotient_hash_rows() const;
    
    // Step 14: Out of domain rows
    struct OutOfDomainRowsData {
        std::string out_of_domain_point_curr_row;
        std::string out_of_domain_point_next_row;
    };
    OutOfDomainRowsData load_out_of_domain_rows() const;
    
    // Step 15: Linear combination
    struct LinearCombinationData {
        size_t combination_codeword_length;
    };
    LinearCombinationData load_linear_combination() const;
    
    // Step 16: DEEP
    struct DeepData {
        size_t deep_codeword_length;
    };
    DeepData load_deep() const;
    
    // Step 17: Combined DEEP polynomial
    struct CombinedDeepPolynomialData {
        size_t fri_combination_codeword_length;
    };
    CombinedDeepPolynomialData load_combined_deep_polynomial() const;
    
    // Step 18: FRI
    struct FriData {
        size_t num_revealed_indices;
    };
    FriData load_fri() const;
    
    // Step 19: Open trace leafs
    struct OpenTraceLeafsData {
        size_t num_revealed_main_rows;
        size_t num_revealed_aux_rows;
        size_t num_revealed_quotient_rows;
    };
    OpenTraceLeafsData load_open_trace_leafs() const;
    
    // Step 1 sample: Trace execution sample
    struct TraceExecutionSampleData {
        std::vector<uint64_t> first_row;
        std::vector<uint64_t> last_row;
    };
    TraceExecutionSampleData load_trace_execution_sample() const;
    
    // Step 5: Main tables LDE (metadata only - full data is too large)
    struct MainTableLdeData {
        std::array<size_t, 2> lde_table_shape;
    };
    MainTableLdeData load_main_table_lde_metadata() const;
    
    // Step 8: Aux tables LDE (metadata only)
    struct AuxTableLdeData {
        std::array<size_t, 2> aux_lde_table_shape;
    };
    AuxTableLdeData load_aux_table_lde_metadata() const;
    
    // Step 11: Quotient LDE (metadata only)
    struct QuotientLdeData {
        std::array<size_t, 2> quotient_segments_shape;
    };
    QuotientLdeData load_quotient_lde_metadata() const;
    
    // Merkle root data with num_leafs
    struct MerkleRootWithLeafsData {
        std::string merkle_root_hex;
        size_t num_leafs;
    };
    MerkleRootWithLeafsData load_main_tables_merkle_full() const;
    MerkleRootWithLeafsData load_aux_tables_merkle_full() const;
    MerkleRootWithLeafsData load_quotient_merkle_full() const;
    
    // Generic JSON access
    nlohmann::json load_json(const std::string& filename) const;
    
private:
    std::string test_data_dir_;
    
    // Helper to construct file path
    std::string file_path(const std::string& filename) const;
};

} // namespace triton_vm

