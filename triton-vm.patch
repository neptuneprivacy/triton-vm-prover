diff --git a/triton-vm/src/error.rs b/triton-vm/src/error.rs
index bc17d95e..40407a98 100644
--- a/triton-vm/src/error.rs
+++ b/triton-vm/src/error.rs
@@ -169,6 +169,9 @@ pub enum ProvingError {
 #[non_exhaustive]
 #[derive(Debug, Error)]
 pub enum VerificationError {
+    #[error("received a logâ‚‚ padded height larger than (or equal to) 32")]
+    Log2PaddedHeightTooLarge,
+
     #[error("received and computed out-of-domain quotient values don't match")]
     OutOfDomainQuotientValueMismatch,
 
diff --git a/triton-vm/src/fri.rs b/triton-vm/src/fri.rs
index 60e4574a..7b3fc610 100644
--- a/triton-vm/src/fri.rs
+++ b/triton-vm/src/fri.rs
@@ -1012,7 +1012,7 @@ mod tests {
 
         let verdict = fri.verify(&mut proof_stream);
         let_assert!(Err(err) = verdict);
-        assert!(let FriValidationError::LastRoundPolynomialEvaluationMismatch = err);
+        assert!(let FriValidationError::BadMerkleAuthenticationPath = err);
     }
 
     #[proptest]
diff --git a/triton-vm/src/proof.rs b/triton-vm/src/proof.rs
index d613d72c..1b6e9c41 100644
--- a/triton-vm/src/proof.rs
+++ b/triton-vm/src/proof.rs
@@ -30,7 +30,7 @@ use crate::proof_stream::ProofStream;
 ///
 /// This version is separate from the crate's semantic version to allow software
 /// upgrades with no semantic changes to both, the ISA and the proof system.
-pub const CURRENT_VERSION: u32 = 0;
+pub const CURRENT_VERSION: u32 = 1;
 
 /// Contains the necessary cryptographic information to verify a computation.
 /// Should be used together with a [`Claim`].
@@ -216,11 +216,11 @@ mod tests {
 
         insta::assert_snapshot!(
             Tip5::hash(&proof),
-            @"09201244033942307448,\
-              02199220141408935358,\
-              14798078607418975656,\
-              16178332457365390929,\
-              00369058580658580912",
+            @"03679712315797441546,\
+              11839395418856928549,\
+              03557811864671638150,\
+              07068928384145787880,\
+              05899970860911282282",
         );
     }
 }
diff --git a/triton-vm/src/proof_item.rs b/triton-vm/src/proof_item.rs
index b5f63271..5fca7724 100644
--- a/triton-vm/src/proof_item.rs
+++ b/triton-vm/src/proof_item.rs
@@ -103,18 +103,52 @@ macro_rules! proof_items {
 
 proof_items!(
     MerkleRoot(Digest) => true, try_into_merkle_root,
+    Log2PaddedHeight(u32) => true, try_into_log2_padded_height,
     OutOfDomainMainRow(Box<MainRow<XFieldElement>>) => true, try_into_out_of_domain_main_row,
     OutOfDomainAuxRow(Box<AuxiliaryRow>) => true, try_into_out_of_domain_aux_row,
     OutOfDomainQuotientSegments(QuotientSegments) => true, try_into_out_of_domain_quot_segments,
+    FriPolynomial(Polynomial<'static, XFieldElement>) => true, try_into_fri_polynomial,
 
-    // implied by some Merkle root: not included in the Fiat-Shamir heuristic
+    // For performance reasons (only!), the following items are not included in
+    // the Fiat-Shamir heuristic. The resulting proof system is still sound if
+    // (and only if!) the prover has already committed to the item in question
+    // in some other fashion.
+    //
+    // Before including additional items in the section below, make certain that
+    // the prover is _actually_ committed to the item in some other fashion.
+    // An oversight will lead (and has led) to soundness vulnerabilities. If you
+    // are unsure, better err on the side of performance degradation than on the
+    // side of an unsound verifier.
+    //
+    // Ideally, write down the argument right above the item; bonus points if
+    // you write down a proof instead. This helps in making assumptions (more)
+    // explicit.
+
+    // 1. An authentication structure is only valid with respect to some
+    //    `MerkleRoot`.
+    // 2. Merkle roots alter the Fiat-Shamir state, committing the prover.
+    // 3. For every authentication structure we supply, the corresponding Merkle
+    //    root is integrated into the proof stream first.
+    // 4. The verifier samples the indices the prover should open.
     AuthenticationStructure(AuthenticationStructure) => false, try_into_authentication_structure,
+
+    // 1. A (main, aux, or quotient-segment) row is only hashed in full, never
+    //    partially.
+    // 2. All rows of a table are put into a Merkle tree.
+    // 3. The root of that tree is integrated into the proof stream before
+    //    any row is revealed.
+    // 4. The verifier dictates which rows to reveal.
     MasterMainTableRows(Vec<MainRow<BFieldElement>>) => false, try_into_master_main_table_rows,
     MasterAuxTableRows(Vec<AuxiliaryRow>) => false, try_into_master_aux_table_rows,
-    Log2PaddedHeight(u32) => false, try_into_log2_padded_height,
     QuotientSegmentsElements(Vec<QuotientSegments>) => false, try_into_quot_segments_elements,
+
+    // 1. The Merkle root of the tree of the codeword is integrated into the
+    //    proof stream before the codeword is sent.
     FriCodeword(Vec<XFieldElement>) => false, try_into_fri_codeword,
-    FriPolynomial(Polynomial<'static, XFieldElement>) => false, try_into_fri_polynomial,
+
+    // Since a `FriResponse` is both, an authentication structure and some
+    // revealed elements, the arguments of `AuthenticationStructure` and the
+    // tables' rows apply.
     FriResponse(FriResponse) => false, try_into_fri_response,
 );
 
diff --git a/triton-vm/src/stark.rs b/triton-vm/src/stark.rs
index 59fe3cee..4837e4c8 100644
--- a/triton-vm/src/stark.rs
+++ b/triton-vm/src/stark.rs
@@ -1156,8 +1156,12 @@ impl Verifier {
         profiler!(stop "Fiat-Shamir: Claim");
 
         profiler!(start "derive additional parameters");
-        let log_2_padded_height = proof_stream.dequeue()?.try_into_log2_padded_height()?;
-        let padded_height = 1 << log_2_padded_height;
+        let log2_padded_height = proof_stream.dequeue()?.try_into_log2_padded_height()?;
+        if log2_padded_height >= 32 {
+            return Err(VerificationError::Log2PaddedHeightTooLarge);
+        };
+
+        let padded_height = 1 << log2_padded_height;
         let fri = self.parameters.fri(padded_height)?;
         let merkle_tree_height = fri.domain.len().ilog2();
 
@@ -1912,14 +1916,37 @@ pub(crate) mod tests {
 
         insta::assert_snapshot!(
             Tip5::hash(&proof),
-            @"17275651906185656762,\
-              13250937299792022858,\
-              05731754925513787901,\
-              05512095638892086027,\
-              08634562101877660478",
+            @"08133801845754967830,\
+              12011037839595956778,\
+              14175473847383162005,\
+              05024926201443895262,\
+              17294001373192224874",
         );
     }
 
+    #[proptest]
+    fn too_high_padded_height_results_in_immediate_verification_failure(
+        #[strategy(32_u32..)] height: u32,
+    ) {
+        let program = triton_program!(halt);
+        let claim = Claim::about_program(&program);
+        let (aet, _) =
+            VM::trace_execution(program, PublicInput::default(), NonDeterminism::default())?;
+
+        let stark = Stark::low_security();
+        let proof = stark.prove(&claim, &aet)?;
+        let mut proof_stream = ProofStream::try_from(&proof)?;
+        for proof_item in &mut proof_stream.items {
+            if let ProofItem::Log2PaddedHeight(h) = proof_item {
+                *h = height
+            };
+        }
+        let proof = Proof::from(proof_stream);
+
+        let verdict = stark.verify(&claim, &proof);
+        let_assert!(Err(VerificationError::Log2PaddedHeightTooLarge) = verdict);
+    }
+
     #[test]
     fn print_ram_table_example_for_specification() {
         let program = triton_program!(
